# OSI_Theory
Теория для сдачи лаб по предмету OSI 


									lab_5


									Open


int open(const char *path, int oflag, ... /* mode_t mode */ );

	Аргумент path представляет имя файла, который будет открыт или создан. Эти
функции могут принимать большое количество параметров, определяемых ар-
гументом oflag. Значение этого аргумента формируется объединением по ИЛИ
(OR) одной или более констант, определяемых в заголовочном файле <fcntl.h>
и перечисленных ниже:
      O_RDONLY Файл открывается только на чтение.
      O_WRONLY Файл открывается только на запись.
      O_RDWR Файл открывается для чтения и для записи.
      O_EXEC Файл открывается только для выполнения.
      O_SEARCH Файл открывается только для поиска (применяется к каталогам).
эти - обязательные есть ещё +-15 необязательных ( 105 стр.)

	Что произойдет, если конфигурационный параметр NAME_MAX имеет значение 14 !255
и мы попытаемся создать новый файл, имя которого состоит из 15 символов? Тра-
диционно ранние версии System V, такие как SVR2, допускали это, просто усекая
длину имени файла до 14 символов. BSD-системы возвращали признак ошибки
с кодом ENAMETOOLONG в переменной errno.        /////////////////////////////////////////////// если превышена длинна пути 1024
	Конфигурационный параметр _POSIX_NO_TRUNC, предусматриваемый стандартом
POSIX.1, определяет, усекаются ли слишком длинные имена файлов и строки
пути или возвращается признак ошибки.


									lseek


	С любым открытым файлом связано такое понятие, как текущая позиция в файле.
Как правило, это неотрицательное целое число, которым выражается смещение
в байтах от начала файла. (Некоторые исключения, касающиеся слова «неотри-
цательное», будут упомянуты чуть позже.) Обычно операции чтения и записи
начинают выполняться с текущей позиции в файле и увеличивают ее значение
на количество прочитанных или записанных байтов. По умолчанию при откры-
тии файла текущая позиция инициализируется числом 0, если не был установлен
флаг O_APPEND.

off_t lseek(int fd, off_t offset, int whence);

Интерпретация аргумента offset зависит от значения аргумента whence.
        Если аргумент whence имеет значение SEEK_SET, то offset интерпретируется как
смещение от начала файла.
        Если аргумент whence имеет значение SEEK_CUR, то offset интерпретируется как
смещение от текущей позиции в файле. В этом случае offset может принимать
и положительные, и отрицательные значения.
        Если аргумент whence имеет значение SEEK_END, то offset интерпретируется как
смещение от конца файла. В этом случае offset может принимать и положи-
тельные, и отрицательные значения.

	Текущая позиция в файле может превышать его текущий размер. В этом случае
следующая операция записи увеличит размер файла. Это вполне допустимо и мо-
жет рассматриваться как создание «дырки» в файле. Байты, которые фактически
не были записаны, считываются как нули.
«Дырка» в файле не обязательно должна занимать место на диске. В некоторых
файловых системах в случае переноса текущей позиции за пределы файла на дис-
ке могут выделяться новые блоки для данных, но это совершенно необязательно.

									read

ssize_t read(int fd, void *buf, size_t nbytes);
	Возвращает количество прочитанных байтов,
0 — если достигнут конец файла, –1 — в случае ошибки (стр 114)


									Lab 6


									select 

Функция select позволяет производить мультиплексирование ввода/вывода на
любой POSIX-совместимой платформе. Аргументы, которые передаются функ-
ции select, сообщают ядру:
          список интересующих дескрипторов;
          какие состояния каждого из дескрипторов нас интересуют (готовность к чте-
нию, готовность к записи, наличие исключительной ситуации);
          как долго ожидать изменения состояния дескриптора (не ограничивать время
ожидания, определить некоторый интервал времени или вообще не ждать).
По возвращении из функции ядро сообщает:
          общее количество дескрипторов, перешедших в требуемое состояние;
          какие из дескрипторов готовы для чтения, какие для записи и для каких была
обнаружена исключительная ситуация.

int select(int maxfdp1, fd_set *restrict readfds, fd_set *restrict writefds,
	fd_set *restrict exceptfds, struct timeval *restrict tvptr);

	Для начала рассмотрим последний аргумент. Он определяет продолжительность
времени ожидания в секундах и микросекундах. Второй, третий и четвертый аргументы — readfds, 
writefds и exceptfds — представляют собой указатели на наборы дескрипторов.
 Эти три набора определяют, какие дескрипторы нас интересуют и в каких состояниях 
(готовность к чтению, к записи или наличие исключительной ситуации).	(подробнее на стр. 581)
	Единственное, что можно сделать с переменными типа fd_set, — присвоить зна-
чение одной переменной этого типа другой переменной того же типа или передать
переменную одной из следующих функций.
FD_ZERO (fd_set * fdset); Очистить указанный набор файловых дескрипторов. 
Перед установкой набора файловых дескрипторов он должен быть инициализирован. 
FD_SET (fd_set * fdset); Используется для добавления нового дескриптора файла в набор дескрипторов файла.

									select 

	select является системным вызовом и интерфейс прикладного программирования
Одним из распространенных применений select за пределами заявленного использования ожидания для 
файловых дескрипторов является реализация переносимой субсекунды сон.
Это может быть достигнуто путем передачи NULL для всех трех аргументов 
fd_set и продолжительности желаемого сна в качестве аргумента timeout.


									Lab_9


							              КОНТЕКСТ ПРОЦЕССА
https://www.opennet.ru/docs/RUS/unix/glava_59.html
									exec

	Когда процесс вызывает одну из функций exeс, он полностью замещается другой программой,
и эта новая программа начинает выполнение собственной функции main. Идентификатор процесса при 
этом не изменяется, поскольку функция exec не создает новый процесс, она просто замещает текущий 
процесс — его сегмент кода, сегмент данных, динамическую область памяти и сегмент стека — другой программой.

#include <unistd.h>

int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );

int execv(const char *pathname, char *const argv[]);

int execle(const char *pathname, const char *arg0, ...
/* (char *)0, char *const envp[] */ );

int execve(const char *pathname, char *const argv[], char *const envp[]);

int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );

int execvp(const char *filename, char *const argv[]);

int fexecve(int fd, char *const argv[], char *const envp[]);

Все семь функций возвращают –1 в случае ошибки,
не возвращают управление в случае успеха
	Уже отмечалось, что идентификатор процесса не изменяется после вызова функ-
ции exec. Кроме того, новая программа наследует от вызывающего процесса ряд
дополнительных характеристик:
    идентификатор процесса и идентификатор родительского процесса;
    реальный идентификатор пользователя и реальный идентификатор группы;
    идентификаторы дополнительных групп;
    идентификатор группы процессов;
    идентификатор сеанса;
    управляющий терминал;
    время, оставшееся до срабатывания таймера;
    текущий рабочий каталог;
    корневой каталог;
    маску режима создания файлов;
    блокировки файлов;
    маску сигналов процесса;
    сигналы, ожидающие обработки;
    ограничения на ресурсы;
    значение приоритета
    значения tms_utime, tms_stime, tms_cutime и tms_cstime.
							int execlp(const char *file, const char *arg, ...);

Говорит, что execlp-это функция аргумента переменной. Это занимает 2 const char *. 
Остальные аргументы, если таковые имеются, являются дополнительными аргументами для передачи программе,
 которую мы хотим запустить - также char *- все это строки C (и последний аргумент должен быть нулевым указателем)
Итак, fileаргумент-это имя пути к исполняемому файлу, который должен быть выполнен. 
arg это строка, которую мы хотим отобразить как argv[0]в исполняемом файле.
 По соглашению, argv[0]это просто имя файла исполняемого файла, обычно оно установлено так же, как file.
Теперь ... это дополнительные аргументы для исполняемого файла.

									fork

	Любой процесс может создать новый процесс, вызвав функцию fork.
Новый процесс, созданный функцией fork, называется дочерним процессом, или
процессом-потомком. Эта функция вызывается один раз, а управление возвра-
щает дважды, с единственным отличием: в дочернем процессе она возвращает 0,
а в родительском — идентификатор созданного дочернего процесса. Последнее
обстоятельство объясняется тем, что процесс может иметь несколько потомков,
а система не предусматривает функций, с помощью которых можно было бы по-
лучить идентификаторы дочерних процессов.
	И родительский и дочерний процессы продолжают выполнение программы с ин-
струкции, следующей за вызовом функции fork. Процесс-потомок является точ-
ной копией родительского процесса. Например, потомок получает копии сегмента
данных, кучи и стека родителя.
	Современные версии UNIX не производят немедленного полного копирования
сегмента данных, стека и кучи, потому что часто вслед за вызовом fork сразу же
следует вызов exec. Поэтому используется метод, который получил название ко-
пирование при записи (copy-on-write, COW). Указанные выше области памяти ис-
пользуются совместно обоими процессами, но ядро делает их доступными только
для чтения. Если один из процессов попытается изменить данные в этих областях,
ядро немедленно создаст копию конкретного участка памяти;
	Когда при запуске программы мы перенаправляем стандартный
вывод родительского процесса в файл, стандартный вывод дочернего процес-
са также оказывается перенаправленным. Действительно, одна из особенностей
функции fork в том, что она передает дочернему процессу дубликаты всех де-
скрипторов, открытых в родительском процессе.

									wait

	Если дочерний процесс полностью исчезнет,
родительский процесс не сможет получить его код завершения, когда это потре-
буется. Ядро сохраняет некоторый объем информации о каждом завершившемся
процессе, чтобы она была доступна, когда родительский процесс вызовет функ-
цию wait или waitpid. В простейшем случае эта информация состоит из иденти-
фикатора процесса, кода завершения и количества процессорного времени, затра-
ченного процессом.



									Lab_10


	Когда процесс завершается, обычным образом или аварийно, ядро извещает об
этом родительский процесс с помощью сигнала SIGCHLD. Поскольку завершение
дочернего процесса есть событие асинхронное (оно может произойти в любой мо-
мент), то и сигнал является асинхронным извещением, посылаемым ядром роди-
тельскому процессу. Родительский процесс может проигнорировать сигнал или
определить функцию, которая будет вызвана по прибытии сигнала, — обработчик
сигнала. По умолчанию процессы игнорируют этот сигнал.

WIFEXITED(status) 		Возвращает true, если код status получен в результате нормаль-
			ного завершения дочернего процесса. В этом случае можно извлечь
			младшие 8 бит из аргумента, который был передан функции exit,
			_exit или _Exit:  WEXITSTATUS(status)

WIFSIGNALED(status) 	Возвращает true, если код status получен в результате ненор-
			мального (аварийного) завершения дочернего процесса из-за
			сигнала, который не был перехвачен. В этом случае можно узнать
			номер сигнала, вызвавшего завершение дочернего процесса:
			WTERMSIG(status)
			Кроме того, в некоторых реализациях (но не в Single UNIX Specification) определен макрос
			WCOREDUMP(status) который возвращает true, если в результате аварийного заверше-
			ния процесса создан файл с дампом памяти (core-файл)

WIFSTOPPED(status) 	Возвращает true, если код status получен в результате остановки
			дочернего процесса по сигналу. В этом случае можно узнать номер
			сигнала, который вызвал остановку процесса, с помощью макроса WSTOPSIG(status)

WIFCONTINUED(status) 	Возвращает true, если код status получен для дочернего процесса, 
			который продолжил работу после остановки (расширение XSIв стандарте 
			POSIX.1 — только для функции waitpid)

									lab_11


	Каждой программе, помимо аргументов командной строки, передается также спи-
сок переменных окружения. Подобно списку аргументов командной строки, спи-
сок переменных окружения доступен как массив указателей, каждый из которых
указывает на строку, завершающуюся нулевым символом. Адрес массива указате-
лей хранится в глобальной переменной environ:    extern char **environ;


									lab_16


									tcgetattr,   tcsetattr 
tcgetattr 		Получить характеристики терминала (структура termios)
tcsetattr 		Изменить характеристики терминала (структура termios)

int tcgetattr(int fd, struct termios *termptr);
int tcsetattr(int fd, int opt, const struct termios *termptr);
	Обе возвращают 0 в случае успеха, –1 — в случае ошибки

Аргумент opt функции tcsetattr позволяет определить, когда новые характери-
стики терминала должны вступить в силу. В этом аргументе можно передать одну
из следующих констант:
          TCSANOW Изменения вступают в силу немедленно.							/////////////////////////////
          TCSADRAIN Изменения вступят в силу после отправки всех данных в очереди вы-
вода. Эта константа используется в случае, если изменяются характеристики вы-
вода.
          TCSAFLUSH Изменения вступят в силу после отправки всех данных в очереди
вывода. Кроме того, когда изменения вступят в силу, все непрочитанные данные
в очереди ввода уничтожаются (сбрасываются).
	Каждому из перечисленных флагов соответствует один или более разрядов, если
только флаг не является маской. Флаг-маска определяет набор сгруппированных
разрядов, которые можно установить или сбросить. Шесть значений задержек, которые 
поддерживаются в Linux и Solaris, также являются масками: BSDLY, CRDLY, FFDLY, NLDLY, 
TABDLY и VTDLY. Значение каждой из них вы найдете на странице справочного руководства termio(7I) в Solaris.
(точнее стр 788)
	ECHO (c_lflag, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) Если флаг установ-					/////////////////////////////
лен, производится эхо-вывод введенных символов. Эхо-вывод может работать как
в каноническом, так и в неканоническом режиме. (отображает текст сообщения на экран)
	ICANON (c_lflag, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) Если флаг уста-					/////////////////////////////
новлен, вступает в силу канонический режим (раздел 18.10). В этом режиме раз-
решена обработка символов: EOF, EOL, EOL2, ERASE, KILL, REPRINT, STATUS и WERASE.
Вводимые символы собираются в строки.
	./ Канонический режим очень прост: мы запускаем операцию чтения, а драйвер тер-
	минала возвращает строку, когда она будет введена. Операция чтения завершает-
	ся в следующих ситуациях:
          	           Когда прочитано запрошенное количество байтов. Строка при этом может
	быть прочитана не до конца. Если прочитана только часть строки, оставшаяся
	ее часть не будет потеряна; ее можно прочитать следующей операцией чтения.
          	           Когда достигнут разделитель строк. В каноническом режиме разделителями строк служат
	символы NL, EOL, EOL2 и EOF. 
	           Операция чтения также может завершиться, если перехвачен сигнал и систем-
	ный вызов не перезапускается автоматически /.
	

									Lab_17

	STDIN_FILENO - дескриптор файла стандартного ввода
	TCSAFLUSH - выше
	Функция iscntrl ( сharacter ) проверяет, является ли аргумент, передаваемый через параметр сharacter, 
управляющим символом.
	Функция isprint ( сharacter ) проверяет значение аргумента, передаваемого через  параметр сharacter,
представляет ли оно собой печатный символ.
	В каноническом режиме работы терминала:
		1)    [D - Move cursor left one char
                	2)    [K - Clear line from cursor right
		3)    [2K - Clear entire line
		4)    [<n>D - Move cursor left n chars
	Операция записи содержимого стандартного буфера ввода/вывода описыва-
ется термином flush (сбрасывать).
	Когда вводится символ ERASE, стирается последний символ в текущей строке.	                Backspace 
	Когда вводится символ KILL, стираются все символы в текущей строке.			Ctr+U
	Когда вводится CTRL-W, стирается последнее слово в текущей строке, вместе со всеми следующими за ним пробелами.
	Программа завершается, когда введен CTRL-D и курсор находится в начале строки.
	Все непечатаемые символы, кроме перечисленных выше, должны издавать звуковой сигнал, выводя на терминал символ CTRL-G.
	Длина строки ограничена 40 символами. Если какое-то слово пересекает 40-й столбец, это слово должно быть помещено в начало следующей строки.

struct termios {
     tcflag_t c_iflag; /* флаги режима ввода */
     tcflag_t c_oflag; /* флаги режима вывода */
     tcflag_t c_cflag; /* флаги режима управления */
     tcflag_t c_lflag; /* флаги локального режима */
     cc_t c_cc[NCCS]; /* управляющие символы */
};
	Массив c_cc хранит все специальные символы, которые можно изменить.
Константа NCCS определяет количество элементов этого массива, обычно ее зна-
чение находится в диапазоне от 15 до 20 (поскольку большинство версий UNIX
поддерживают более 11 управляющих символов, определяемых стандартом POSIX.1).

    newsettings.c_cc[VMIN] = 1;
    newsettings.c_cc[VTIME] = 0;
Здесь указывается минимальное количество символов, которое будет передано за раз
— для неканонического ввода (то количество символов, которое будет отдано функции read 
до истечения таймаута VTIME). А также таймаут, в децисекундах, после которого будет отдано 
накопившееся количество символов функции read.

	printf("\33") = esc

dev/tty

ps -Alf | grep "d.kur"
kill -SUGINT ......

							lab_19


Функция glob() выполняет поиск всех путей, соответствующих
шаблону, в соответствии с правилами, используемыми оболочкой.

 Функция globfree() освобождает динамически выделенное хранилище
от предыдущего вызова функции glob().

 Результаты вызова glob() сохраняются в структуре, на которую указывает
pglob. Эта структура имеет тип glob_t (объявленный в
<glob.h>) и включает в себя следующие элементы, определенные POSIX.2
 (больше может присутствовать в качестве расширения):

{
 size_t gl_pathc; 	/* Количество путей, совпадающих до сих пор */
 char **gl_pathv; 	/* Список совпадающих имен путей. */
 size_t gl_offs;	 /* Слоты для резервирования в gl_pathv. */
 } glob_t;

 Результаты хранятся в динамически выделенном хранилище.

 Аргумент flags состоит из побитовых ИЛИ нулевых или более
следующих символьных констант, которые изменяют поведение
функции glob():

 GLOB_ERR
 Возврат при ошибке чтения (например, потому что каталог не
имеет разрешения на чтение). По умолчанию glob()
 попытки продолжаются, несмотря на ошибки, читая все
каталоги, которые он может.

 GLOB_MARK
 Добавьте косую черту к каждому пути, который соответствует
каталогу.

 Если errfunc не равен NULL, он будет вызван в случае ошибки
с аргументами epath, указатель на путь, который не удался, и
eerrno, значение errno, возвращенное из одного из вызовов
opendir(3), readdir(3)или stat(2). Если errfunc возвращает ненулевое
значение или если установлен GLOB_ERR, glob() завершится после вызова
errfunc.

 После успешного возврата pglob->gl_pathc содержит количество
совпадающих имен путей, а pglob->gl_pathv содержит указатель на
список указателей на совпадающие имена путей. Список указателей
заканчивается нулевым указателем.
  
  								lab_21

что такое сигнал, как работает, когда появляются, как действуют(диспозиция сигнала 3), сигналы в программе
signal, sigset, почему лучше не использовать 1
реинтерабельная функция

Сигналы — это программные прерывания.Сигналы дают возможность обработки асин-
хронных событий — например, когда пользователь вводит символ прерывания,
чтобы остановить программу, или когда одна из программ в конвейере заверша-
ется аварийно.

в Solaris 10 — 40 различных сигналов.

Все имена сигналов определены как константы с положительными числовыми
значениями (номерами сигналов) в заголовочном файле <signal.h>.

когда появляются: 
		Сигналы, генерируемые терминалом, возникают, когда пользователь вводит
	определенные символы.Нажатие клавиши DELETE (или Control-C — в большин-
	стве систем) порождает сигнал прерывания (SIGINT).
		Аппаратные ошибки
		Функция kill(2) позволяет процессу передать любой сигнал другому процес-
	су или группе процессов.
		Команда kill(1) позволяет передавать сигналы другим процессам.
		Сигналы могут порождаться при условиях, определяемых программно, на-
	пример, когда нужно известить приложение о наступлении некоторого со-
	бытия.
В случае появления сигнала можно запросить ядро произвести одно из трех дей-
ствий. Они называются диспозициями сигнала, или действиями, связанными
с сигналом:
		Игнорировать сигнал. Это действие возможно для большинства сигналов, но
	два сигнала, SIGKILL и SIGSTOP, нельзя игнорировать.
		Перехватить сигнал. Для этого нужно сообщить ядру адрес функции, которая
	будет обрабатывать сигнал. В этой функции можно предусмотреть действия по
	обработке условия, породившего сигнал.
		Применить действие по умолчанию. Каждому сигналу поставлено в соответ-
	ствие некоторое действие по умолчанию

		signal
Функция signal — это простейший интерфейс к сигналам UNIX.
	Функция signal определена стандартом ISO C, который ничего не говорит о многоза-
дачности, группах процессов, терминальном вводе/выводе и т. п. Поэтому определение
сигналов в этом стандарте практически бесполезно для систем UNIX.
	Реализации, происходящие от System V, поддерживают функцию signal, но она предо-
ставляет устаревшую семантику механизма ненадежных сигналов. Эта функция обеспечивает 
обратную совместимость с приложениями, требующими устаревшей семантики. Новые приложения
не должны использовать ненадежные сигналы.
		 Реентерабельные функции
// вспонить о чём речь//
	Когда процесс обрабатывает перехваченный сигнал, нормальная последователь-
ность выполнения инструкций временно нарушается обработчиком сигнала. По-
сле этого процесс продолжает работу, но выполняет инструкции уже в функции-
обработчике. Если обработчик сигнала возвращает управление (а не вызывает,
например, функцию exit или longjmp), процесс продолжает выполнение нор-
мальной последовательности инструкций, прерванной перехваченным сигналом.
(Это напоминает ситуацию, когда работа приложения прерывается аппаратным
прерыванием.) Но, находясь внутри обработчика сигнала, мы не можем опреде-
лить, в каком месте процесса произошло прерывание. А что, если процесс вызвал
функцию malloc, чтобы распределить дополнительную память, и обработчик сиг-
нала также вызвал функцию malloc? В случае функции malloc результа-
ты такого вызова могут оказаться разрушительными для приложения, посколь-
ку обычно функция malloc поддерживает связанный список всех выделенных ею
областей памяти и вызов из обработчика сигнала может произойти как раз в тот
момент, когда она вносит изменения в этот список.
//

	Стандарт Single UNIX Specification определяет перечень функций, которые долж-
ны обеспечивать безопасность вызова из обработчиков сигналов. Эти функции
являются реентерабельными и в стандарте Single UNIX Specification называют-
ся безопасными для использования в обработчиках асинхронных сигналов. Поми-
мо обеспечения реентерабельности, они блокируют доставку любых сигналов
до своего завершения, если это может вызвать нарушения в работе приложения.



ps -Alf | grep "d.kur"
kill -SIGINT ......


								Lab_25



Неименованные каналы (pipes, далее для краткости просто каналы) — это старей-
шая форма организации взаимодействий между процессами, предоставляемая
операционными системами UNIX. Каналы имеют два ограничения:
	1. Исторически они являются полудуплексными (то есть данные могут переда-
ваться по ним только в одном направлении). Некоторые современные системы
предоставляют дуплексные каналы, но для сохранения переносимости прило-
жений никогда не следует пользоваться этой возможностью.
	2. Каналы могут использоваться только для организации взаимодействий меж-
ду процессами, которые имеют общего предка. Обычно канал создается ро-
дительским процессом, который затем вызывает функцию fork, после чего
канал может использоваться для общения между родительским и дочерним
процессами.

int pipe(int fd[2]);

	Возвращает 0 в случае успеха, –1 — в случае ошибки

Через аргумент fd возвращаются два файловых дескриптора: fd[0] открыт для
чтения, а fd[1] — для записи. Данные, выводимые в fd[1], становятся входными
данными для fd[0].



								Lab_26



Поскольку чаще всего канал создается для взаимодействия с другим процессом,
чтобы получать от него или отправлять ему данные, стандартная библиотека вво-
да/вывода традиционно поддерживает функции pclose и popen. Эти две функции
берут на себя всю рутинную работу, которую мы до сих пор выполняли самостоя-
тельно: создание канала, создание дочернего процесса, закрытие неиспользуемых
дескрипторов канала, запуск команды и ожидание завершения команды.

FILE *popen(const char *cmdstring, const char *type);

	Возвращает указатель на структуру FILE в случае успеха,
	NULL — в случае ошибки

int pclose(FILE *fp);

	Возвращает код завершения cmdstring, –1 — в случае ошибки

Функция popen посредством fork и exec запускает команду cmdstring и возвра-
щает указатель на объект FILE. Если в аргументе type передается значение "r",
указатель на файл будет связан со стандартным выводом cmdstring

  родительский поцесс 				дочерний процесс
	fp		<--------------------- 	          stdout

Если в аргументе type передается значение "w", указатель на файл будет связан со
стандартным вводом cmdstring

  родительский поцесс 				дочерний процесс
	fp		---------------------> 	          stdin

Функция pclose закрывает поток ввода/вывода, ожидает завершения коман-
ды и возвращает код завершения командного интерпретатора, запущенного для
выполнения команды cmdstring.
	

	tr [КЛЮЧ]... НАБОР1 [НАБОР2]
Утилита tr копирует стандартный ввод в стандартный вывод с заменой или удалением 
выбранных символов.  Указанные параметры и операнды string1 и string2 управляют 
переводами, которые происходят при копировании символов и односимвольных элементов 
сопоставления.

Ключи:		 c, -C	Сначала получить дополнение НАБОРА1
		-d	Удалить знаки из НАБОРА2, не превращать
		-s	Замещать последовательность знаков, которые повторяются, 
			из перечисленных 
			в последнем НАБОРЕ, на один такой знак
		-t	Сначала сократить НАБОР1 до размеров НАБОРА2

НАБОРЫ:
		[:alnum:]	Все буквы и цифры
		[:alpha:]	Все буквы
		[:blank:]	Все горизонтальные пробельные символы
		[:cntrl:]	Все управляющие знаки
		[:digit:]	Все цифры
		[:graph:]	Все печатаемые знаки, исключая пробел
		[:lower:]	Все маленькие буквы
		[:print:]	Все печатаемые знаки, включая пробел
		[:punct:]	Все знаки пунктуации
		[:space:]	Все вертикальные и горизонтальные пробельные знаки
		[:upper:]	Все большие буквы
		[:xdigit:]	Все шестнадцатиричные цифры

echo - выводить строку текста в терминал.

int fputs( const char * string, FILE * filestream );
Функция fputs записывает строку, указанную в параметре string в поток filestream.


								Lab_27



wc считывает один или несколько входных файлов и по умолчанию записывает количество символов 
новой СТРОКИ, слов и байтов, содержащихся в каждом входном файле, в стандартный вывод.	
// 26 прекрасно читает из потока вывода буду использовать её пфф

wc -l	--lines	Вывести количество строк в объекте



								Lab_28



попробовать читать сдучайные числа из dev/random




								Lab_30


								SOCKET

Сокет — это абстракция конечной точки взаимодействия. Подобно тому как для
работы с файлами приложения используют дескрипторы файлов, для работы
с сокетами они используют дескрипторы сокетов. В UNIX дескрипторы сокетов
реализованы так же, как дескрипторы файлов.

int socket(int domain, int type, int protocol);

		Возвращает дескриптор файла (сокета) в случае успеха,
		–1 — в случае ошибки

Аргумент domain определяет природу взаимодействия, включая формат адреса.
Домены:	
		AF_INET 			Домен Интернета IPv4
		AF_INET6 			Домен Интернета IPv6 (необязательный в POSIX.1)
		AF_UNIX 			Домен UNIX
		AF_UNSPEC 		Неопределенный домен

В аргументе type указывается тип сокета, который, в свою очередь, определяет ха-
рактеристики взаимодействия.
типы сокетов:
		SOCK_DGRAM 		Не ориентированы на создание логического соединения, сообщения фик-
					сированной длины, доставка сообщений не гарантируется

		SOCK_RAW 		Интерфейс дейтаграмм к протоколу IP (необязателен в POSIX.1)
		SOCK_SEQPACKET 		Ориентированы на создание логического соединения, упорядоченность
					передачи данных, сообщения фиксированной длины, гарантируется до-
					ставка сообщений

		SOCK_STREAM 		Ориентированы на создание логического соединения, упорядоченность
					передачи данных, гарантируется доставка сообщений, двунаправленный
					поток байтов

В аргументе protocol обычно передается значение 0, чтобы выбрать протокол по
умолчанию для данного домена и типа сокета. Если для одного и того же домена
и типа сокета поддерживается несколько протоколов, можно использовать этот
аргумент для выбора конкретного протокола. Протокол по умолчанию для соке-
тов типа SOCK_STREAM из домена AF_INET — TCP (Transmission Control Protocol —
протокол управления передачей данных). Протокол по умолчанию для сокетов
типа SOCK_DGRAM из домена AF_INET — UDP (User Datagram Protocol — протокол
пользовательских дейтаграмм).

								CONNECT

Если мы имеем дело с сетевой службой, которая ориентирована на установление
логического соединения (SOCK_STREAM или SOCK_SEQPACKET), прежде чем начать
обмениваться данными, необходимо установить соединение между сокетом про-
цесса, посылающего запрос (клиентом), и процессом, предоставляющим услугу
(сервером).

int connect(int sockfd, const struct sockaddr *addr, socklen_t len);
		Возвращает 0 в случае успеха, –1 — в случае ошибки

Адрес, который передается функции connect, — это адрес сервера, с которым пред-
полагается установить связь. Если сокету sockfd не присвоен какой-либо адрес,
функция присвоит ему адрес по умолчанию.



Адрес сокетов домена UNIX представлен структурой sockaddr_un.
struct sockaddr_un {
	sa_family_t sun_family; /* AF_UNIX */
	char sun_path[108]; /* полное имя */
};
Поле sun_path содержит полное имя файла. Присваивая имя сокету домена UNIX,
система создает файл типа S_IFSOCK с этим именем.
Этот файл существует, только чтобы сообщить имя сокета клиентам.

								BIND

Адрес, присваиваемый клиентскому сокету, не представляет для нас особого инте-
реса, потому мы можем позволить системе выбирать адрес по умолчанию. Однако
для сервера важно присвоить сокету предопределенный адрес, на который клиенты
будут присылать запросы. Клиентам необходимо заранее знать требуемый адрес,
чтобы войти в контакт с сервером, и самое простое решение заключается в том, что-
бы зарезервировать адрес сервера в файле /etc/services или в службе имен.

int bind(int sockfd, const struct sockaddr *addr, socklen_t len);
	Возвращает 0 в случае успеха, –1 — в случае ошибки

Существует несколько ограничений, касающихся адресов:
 	 Указываемый адрес должен быть действительным адресом для машины, на
	которой выполняется процесс, — нельзя задать адрес, который принадлежит
	другой машине.

	 Формат адреса должен совпадать с форматом, который поддерживается семей-
	ством адресов, указанным при создании сокета.

	 Номер порта не может быть меньше 1024, если процесс не имеет соответствую-
	щих привилегий (например, привилегий суперпользователя).

 	 Обычно каждый конкретный адрес может быть связан только с одним сокетом,
	хотя некоторые протоколы допускают присвоение одного и того же адреса не-
	скольким сокетам.


								LISTEN


С помощью функции listen сервер заявляет о своем желании принимать запросы
на установление соединения.

int listen(int sockfd, int backlog);
	Возвращает 0 в случае успеха, –1 — в случае ошибки

Аргумент backlog определяет желаемое количество ожидающих обработки запро-
сов, которые должны быть поставлены в очередь от имени процесса. Фактическое
значение определяется самой системой, но верхний предел определен под именем
SOMAXCONN в заголовочном файле <sys/socket.h>.
После заполнения очереди система будет отвергать дополнительные запросы на
соединение, поэтому значение backlog должно выбираться с учетом возможной
нагрузки на сервер и объема ресурсов, необходимого для принятия запроса и за-
пуска службы.

								ACCEPT

Функция accept принимает запрос и преобразует его в соединение.

int accept(int sockfd, struct sockaddr *restrict addr,
		socklen_t *restrict len);
	Возвращает дескриптор файла (сокета) в случае успеха,
	–1 — в случае ошибки

Функция accept возвращает дескриптор сокета, соединенного с клиентом, вызвав-
шим функцию connect. Этот новый сокет имеет тот же тип и семейство адресов,
что и сокет sockfd. Первоначальный сокет, который передается функции accept,
не связан с установленным соединением, он остается свободным для приема по-
следующих запросов на соединение.
Если нас не беспокоит проблема идентификации клиента, мы можем передать в ар-
гументах addr и len значение NULL. Иначе необходимо передать в addr адрес буфера
достаточного размера для хранения адреса, а в аргументе len — адрес целого числа,
определяющего размер буфера. По возвращении из функции accept в буфере будет
находиться адрес клиента, а по адресу len — фактический размер адреса.

  

									lab_31


struct pollfd {
                int fd;           /* описатель файла */
                short events;     /* запрошенные события */
                short revents;    /* возвращенные события */
        };

Элемент fd задает дескриптор открытого файла, а элементы events и revents представляют 
собой битовые маски, созданные с помощью логической операции ИЛИ любой комбинации 
следующих флагов событий:

POLLIN
Данные, отличные от данных с высоким приоритетом, могут считываться без блокировки. 

POLLPRI
Высокоприоритетные данные могут быть получены без блокировки.

POLLERR
Произошла ошибка на device или socket 

POLLHUP
device или socket были отключены

POLLNVAL
не открывается дескриптор файлов


Событие		Флаг poll		когда происходит
_______________________________________________________________________
Чтение		POLLIN		пришли новые данные.
_______________________________________________________________________
Чтение		POLLIN		Установка соединения завершена (для сокетов, ориентированных на соединения)
_______________________________________________________________________
Чтение		POLLHUP		Другая сторона инициировала запрос на разъединение.
_______________________________________________________________________
Read		POLLHUP		Соединение разорвано (только для протоколов, ориентированных на соединение). Если производится запись в сокет, то также посылается сигнал SIGPIPE.
_______________________________________________________________________
Запись		POLLOUT		Сокет имеет достаточно места в буфере передачи для записи в него новых данных.
_______________________________________________________________________
Чтение/запись	POLLIN
		POLLOUT		Исходящий connect(2) завершен.
_______________________________________________________________________
Чтение/запись	POLLERR		произошла асинхронная ошибка.
_______________________________________________________________________
Чтение/запись	POLLHUP		другая сторона закрыла (shut down) одно направление.
_______________________________________________________________________
Исключение	POLLPRI		Пришли неотложные данные. При этом посылается сигнал SIGURG.




									lab_36


			SOCKET

int socket(int domain, int type, int protocol);

		Возвращает дескриптор файла (сокета) в случае успеха,
		–1 — в случае ошибки

Аргумент domain определяет природу взаимодействия, включая формат адреса.
Домен		
	AF_INET 			Домен Интернета IPv4



В аргументе type указывается тип сокета, который, в свою очередь, определяет ха-
рактеристики взаимодействия.
типы сокет

		SOCK_STREAM 		Ориентированы на создание логического соединения, упорядоченность
					передачи данных, гарантируется доставка сообщений, двунаправленный
					поток байтов

			GETADDRINFO

int getaddrinfo(const char *node, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);
Мы должны передать функции имя хоста, имя службы или и то и другое. Если
передается только одно имя, второе должно быть пустым указателем. Имя хоста
может быть именем сетевого узла или адресом в десятично-точечной нотации.

struct addrinfo {
    int     ai_flags;
    int     ai_family;
    int     ai_socktype;
    int     ai_protocol;
    size_t  ai_addrlen;
    struct sockaddr *ai_addr;
    char   *ai_canonname;
    struct addrinfo *ai_next;
};
_______________________________________________________________________________________________________
Флаг 			|	Описание
------------------------|-------------------------------------------------------------------------------
AI_ADDRCONFIG 		|	Запрос типа адреса (IPv4 или IPv6)
------------------------|-------------------------------------------------------------------------------
AI_ALL 			|	Поиск обоих типов адресов — IPv4 и IPv6 (используется только совмест-
			|	но с флагом AI_V4MAPPED)
------------------------|-------------------------------------------------------------------------------
AI_CANONNAME 		|	Запрос канонического имени (в противоположность псевдониму)
------------------------|-------------------------------------------------------------------------------
AI_NUMERICHOST 		|	Вернуть адрес в числовом формате
------------------------|-------------------------------------------------------------------------------
AI_NUMERICSERV 		|	Вернуть службу в виде номера порта
------------------------|-------------------------------------------------------------------------------
AI_PASSIVE 		|	Сокет предназначен для работы в режиме прослушивания
------------------------|-------------------------------------------------------------------------------
AI_V4MAPPED 		|	Если адреса IPv6 не найдены, возвращать адреса IPv4 в формате IPv6
________________________|_______________________________________________________________________________

			CONNECT

struct sockaddr {
	u_short	sa_family;
	char	sa_data[14];
};

struct sockaddr_in {
	short	sin_family;
	u_short	sin_port;
	struct in_addr	sin_addr;
	char	sin_zero[8];
};


Если мы имеем дело с сетевой службой, которая ориентирована на установление
логического соединения, прежде чем начать обмениваться данными, необходимо 
установить соединение между сокетом процесса, посылающего запрос (клиентом), 
и процессом, предоставляющим услугу (сервером). Для создания соединения 
используется функция connect.

int connect(int sockfd, const struct sockaddr *addr, socklen_t len);
		Возвращает 0 в случае успеха, –1 — в случае ошибки

Адрес, который передается функции connect, — это адрес сервера, с которым пред-
полагается установить связь. Если сокету sockfd не присвоен какой-либо адрес,
функция присвоит ему адрес по умолчанию.

Попытка соединения с сервером может потерпеть неудачу по нескольким при-
чинам. Машина, с которой устанавливается соединение, должна быть включена
и связана с сетью. Серверу должен быть присвоен адрес, с которым мы пытаемся
соединиться, и в очереди запросов на соединение на стороне сервера должно быть
достаточно места, чтобы поставить в очередь наш запрос

запросы через write

			POLL

int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);
	Возвращает количество готовых дескрипторов, 0 — в случае тайм-аута,
	–1 — в случае ошибки

Вместо того чтобы строить наборы дескрипторов для проверки трех возможных
условий (готовность к чтению, готовность к записи, наличие исключительной
ситуации), как это делается для функции select(Функция select позволяет 
производить мультиплексирование ввода/вывода на любой POSIX-совместимой 
платформе.), при использовании poll нужно создать массив структур pollfd, 
в котором каждый элемент соответствует определенному дескриптору и 
проверяемому условию:

struct pollfd {
int fd; 	/* номер дескриптора или число <0, */
		/* если номер дескриптора игнорируется */
short events; 	/* интересующие события для заданного дескриптора */
short revents; 	/* происшедшие события для заданного дескриптора */
};

Чтобы сообщить ядру, какие события нас интересуют, мы должны записать в поле
events для каждого элемента массива одно или более значений, перечень которых
приводится в табл далее. По возвращении из функции poll ядро указывает в поле
revents, какие события произошли для каждого из дескрипторов.


Имя 		events 		revents 		Описание

POLLIN 		  +		  + 			Данные, помимо высокоприоритетных, доступны для чте-
							ния без блокировки (эквивалент POLLRDNORM|POLLRDBAND)
------------------------------------------------------------------------------------------------------------------

POLLRDNORM 	  +		  + 	 		Обычные данные (с приоритетом 0) доступны для чтения

							без блокировки
------------------------------------------------------------------------------------------------------------------

POLLRDBAND        +		  + 	 		Данные с ненулевым приоритетом доступны для чтения

							без блокировки
------------------------------------------------------------------------------------------------------------------

POLLPRI 	  +		  + 	 		Высокоприоритетные данные доступны для чтения без

							блокировки
------------------------------------------------------------------------------------------------------------------

POLLOUT 	  +		  +			Обычные данные можно записать без блокировки
------------------------------------------------------------------------------------------------------------------
POLLWRNORM 	  +		  +			 То же, что и POLLOUT
------------------------------------------------------------------------------------------------------------------
POLLWRBAND 	  +		  +			 Данные с ненулевым приоритетом можно записать без

							блокировки
------------------------------------------------------------------------------------------------------------------
POLLERR 			  +			 Возникла ошибка
------------------------------------------------------------------------------------------------------------------
POLLHUP 			  +			 Обрыв связи
------------------------------------------------------------------------------------------------------------------
POLLNVAL 			  +			 Дескриптор не соответствует открытому файлу
------------------------------------------------------------------------------------------------------------------

    #define POLLIN      0x0001    /* Можно считывать данные */
    #define POLLPRI     0x0002    /* Есть срочные данные */
    #define POLLOUT     0x0004    /* Запись не будет блокирована */
    #define POLLERR     0x0008    /* Произошла ошибка */
    #define POLLHUP     0x0010    /* "Положили трубку" */
    #define POLLNVAL    0x0020    /* Неверный запрос: fd не открыт */

						Lab_37



Асинхронный ввод/вывод в POSIX

Интерфейсы асинхронного ввода/вывода, определяемые стандартом POSIX,
дают непротиворечивый способ асинхронного ввода/вывода, независимо от 
типов файлов. Функции асинхронного ввода/вывода используют для описания 
асинхронных операций управляющие блоки AIO. Структура aiocb определяет 
управляющий блок AIO.

struct aiocb {
	int aio_fildes; 			/* дескриптор файла */
	off_t aio_offset; 			/* смещение в файле */
	volatile void *aio_buf; 		/* буфер ввода/вывода */
	size_t aio_nbytes; 			/* количество байтов */
	int aio_reqprio; 			/* приоритет */
	struct sigevent aio_sigevent; 		/* информация о сигнале */
	int aio_lio_opcode; 			/* операция для списка запросов */
};


Поле aio_fildes — это дескриптор открытого файла, к которому применяется опе-
рация чтения или записи. Чтение или запись начинаются со смещения, определя-
емого полем aio_offset. При выполнении операции чтения данные копируются
в буфер, начинающийся с адреса, определяемого полем aio_buf. При выполнении
операции записи данные копируются из этого буфера. Поле aio_nbytes определя-
ет количество байтов, которые нужно прочитать или записать.

Поле aio_reqprio дает приложению возможность подсказать системе, в каком 
порядке должны выполняться асинхронные операции.

Поле aio_lio_opcode используется только в списках запросов на асинхронный 
ввод/вывод.

Поле aio_sigevent определяет спо-
соб извещения приложения о завершении ввода/вывода. Этот способ описывает-
ся структурой sigevent.

struct sigevent {
int sigev_notify; 				/* тип извещения */
int sigev_signo; 				/* номер сигнала */
union sigval sigev_value; 			/* аргумент обработчика */
void (*sigev_notify_function)(union sigval); 	/* функция-обработчик */
pthread_attr_t *sigev_notify_attributes; 	/* атрибуты обработки */
};

						READ/WRITE

Чтобы выполнить асинхронный ввод/вывод, необходимо инициализировать
управляющий блок AIO и вызвать функцию aio_read, чтобы выполнить чтение,
или aio_write, чтобы выполнить запись.

#include <aio.h>
int aio_read(struct aiocb *aiocb);
int aio_write(struct aiocb *aiocb);

	Обе возвращают 0 в случае успеха, –1 — в случае ошибки


Когда эти функции возвращают признак успеха, это означает, что запрошенные
асинхронные операции ввода/вывода поставлены в очередь для обработки. Воз-
вращаемое значение не имеет никакого отношения к результату фактической опе-
рации ввода/вывода. Пока операция ожидает обработки, необходимо обеспечить
надежное хранение управляющего блока AIO и буфера с данными — занимаемая
ими память должна оставаться доступной и не может использоваться для других
нужд, пока операция ввода/вывода не будет выполнена.


Подобно функциям aio_read и aio_write, aio_fsync возвращает управление сра-
зу, как только запрос на выполнение синхронизации будет поставлен в очередь.
Данные не будут сохранены, пока операция синхронизации не завершится. Управ-
ляющий блок AIO также определяет способ извещения приложения, как и при
вызове функций aio_read и aio_write.


точнее на стр. 590
